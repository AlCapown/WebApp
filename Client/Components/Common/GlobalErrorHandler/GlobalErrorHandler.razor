@using System.Threading
@using System.Threading.Channels
@using System.Threading.Tasks
@using Microsoft.Extensions.Logging
@using WebApp.Common.Models
@using WebApp.Common.Infrastructure
@using WebApp.Client.Store.PageStore

@implements IAsyncDisposable

@inject IDispatcher Dispatcher
@inject IActionSubscriber ActionSubscriber
@inject IDialogService DialogService
@inject ILogger<GlobalErrorHandler> Logger
@inject NavigationManager NavigationManager

<ErrorBoundary>
    <ChildContent>
        @ChildContent
    </ChildContent>
    <ErrorContent Context="exception">
        @{ OnException(exception); }
    </ErrorContent>
</ErrorBoundary>


@code 
{
#nullable enable

    [Parameter]
    public required RenderFragment ChildContent { get; set; }

    private readonly CancellationTokenSource _cancellationTokenSource = new();
    private readonly Channel<Func<Task>> _errorQueue = Channel.CreateUnbounded<Func<Task>>(new UnboundedChannelOptions
    {
        SingleReader = true,
        SingleWriter = false,
        AllowSynchronousContinuations = false
    });

    private Task? _processingTask;

    protected override void OnInitialized() 
    {
        ActionSubscriber.SubscribeToAction<PageActions.EnqueuePageError>(this, action => EnqueueError(action));
        _processingTask = ProcessErrorQueue(_cancellationTokenSource.Token);
        base.OnInitialized();
    }

    public async ValueTask DisposeAsync()
    {
        ActionSubscriber.UnsubscribeFromAllActions(this);
        _errorQueue.Writer.Complete();
    
        await _cancellationTokenSource.CancelAsync();
    
        // Wait for background task to complete gracefully
        if (_processingTask is not null)
        {
            try
            {
                await _processingTask;
            }
            catch (OperationCanceledException)
            {
                // Expected
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Unexpected error while disposing GlobalErrorHandler");
            }
        }
    
        _cancellationTokenSource.Dispose();
    }

    private void OnException(Exception ex)
    {
        Dispatcher.Dispatch(new PageActions.EnqueuePageError
        {
            Error = new LocalError
            {
                Message = ex.Message,
                StackTrace = ex.StackTrace
            }
        });
    }

    private void EnqueueError(PageActions.EnqueuePageError errorAction)
    {
        _errorQueue.Writer.TryWrite(() => errorAction.Error switch
        {
            ApiError apiError => ShowApiErrorDialog(apiError),
            LocalError localError => ShowLocalErrorDialog(localError),
            _ => ShowUnsupportedErrorTypeDialog()
        });
    }

    private async Task ProcessErrorQueue(CancellationToken cancellationToken)
    {
        await foreach(var errorTask in _errorQueue.Reader.ReadAllAsync(cancellationToken))
        {
            try
            {
                await errorTask();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error processing error action in GlobalErrorHandler.");
            }
        }
    }

    private async Task ShowApiErrorDialog(ApiError apiError)
    {
        var dialogPrams = new DialogParameters<ErrorDialog>();
        dialogPrams.Add(x => x.Message, apiError.Detail);
        dialogPrams.Add(x => x.IsRetriable, apiError.RetryAction is not null);
        
        var dialog = await DialogService.ShowAsync<ErrorDialog>("Api Error", dialogPrams);
        var dialogResult = await dialog.Result;

        switch (dialogResult?.Data?.ToString())
        {
            case ErrorDialog.ErrorDialogResult.RETRY:
                Dispatcher.Dispatch(apiError.RetryAction);
                break;
            case ErrorDialog.ErrorDialogResult.CANCELLED:
                break;
            case ErrorDialog.ErrorDialogResult.REFRESH:
            default:
                ReloadPage();
                break;
        }
    }

    private async Task ShowLocalErrorDialog(LocalError localError)
    {
        var dialogPrams = new DialogParameters<ErrorDialog>();
        dialogPrams.Add(x => x.Message, localError.Message);
        dialogPrams.Add(x => x.IsRetriable, false);

        var dialog = await DialogService.ShowAsync<ErrorDialog>("Local Error", dialogPrams);
        await dialog.Result;
        ReloadPage();
    }

    private async Task ShowUnsupportedErrorTypeDialog()
    {
        var dialogPrams = new DialogParameters<ErrorDialog>();
        dialogPrams.Add(x => x.Message, "Unsupported error type used.");
        dialogPrams.Add(x => x.IsRetriable, false);
        
        var dialog = await DialogService.ShowAsync<ErrorDialog>("Unsupported Error", dialogPrams);
        await dialog.Result;
        ReloadPage();
    }

    private void ReloadPage()
    {
        NavigationManager.NavigateTo(NavigationManager.Uri, true);
    }
}
